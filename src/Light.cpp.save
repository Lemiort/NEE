#include "Light.h"

DirectionalLight::DirectionalLight(GLfloat d1,GLfloat d2,GLfloat d3,GLfloat r,GLfloat g,GLfloat b)
			{
				direction[0]=d1;
				direction[1]=d2;
				direction[2]=d3;
				direction[3]=1;
				color[0]=r;
				color[1]=g;
				color[2]=b;
			}
Vector3f DirectionalLight::GetDir()
{
    return Vector3f(direction[0],
				direction[1],
				direction[2]);
}
Vector3f DirectionalLight::GetCol()
{
    return Vector3f(color[0],
				color[1],
				color[2]);
}
DirectionalLight::DirectionalLight()
			{
			}
DirectionalLight::~DirectionalLight()
			{
			}
SpotLight::SpotLight()
	{
	}
SpotLight::~SpotLight()
	{
	}
void SpotLight::Init(GLfloat d1,GLfloat d2,GLfloat d3,GLfloat r,GLfloat g,GLfloat b,float p1, float p2, float p3, float cut)
	{
		direction[0]=d1;
				direction[1]=d2;
				direction[2]=d3;
				direction[3]=1;
				color[0]=r;
				color[1]=g;
				color[2]=b;
				position[0]=p1;
				position[1]=p2;
				position[2]=p3;
				Cutoff=cut;
	}
PointLight::PointLight(float d1,float d2,float d3,float r,float g,float b, float p)
			{
				position[0]=d1;
				position[1]=d2;
				position[2]=d3;
				color[0]=r;
				color[1]=g;
				color[2]=b;
				power=p;
				temp[0]=0; temp[1]=0; temp[2]=0;
				char* vertexShaderSorceCode=ReadFile("Shaders/lightVS.vsh");
				char* fragmentShaderSourceCode=ReadFile("Shaders/lightFS.fsh");
				shaderProgram=new Shader();
				shaderProgram->AddShader(vertexShaderSorceCode,VertexShader);
				shaderProgram->AddShader(fragmentShaderSourceCode,FragmnetShader);
				shaderProgram->Init();
				/*GLuint vertexShaderID=MakeVertexShader(vertexShaderSorceCode);
				GLuint fragmentShaderID=MakeFragmentShader(fragmentShaderSourceCode);
				shaderProgramID=MakeShaderProgram(vertexShaderID, fragmentShaderID);*/

				glGenBuffers(1, &VBO);
				glBindBuffer(GL_ARRAY_BUFFER, VBO);
				glBufferData(GL_ARRAY_BUFFER,sizeof(temp),NULL, GL_STATIC_DRAW);
				glBufferSubData(GL_ARRAY_BUFFER,0,sizeof(temp),temp);
				positionID=	    shaderProgram->GetAttribLocation("position");
				gWorldID=	    shaderProgram->GetUniformLocation("gWVCP");
				PixelColorID=   shaderProgram->GetUniformLocation("PixelColor");
				PointSizeID=    shaderProgram->GetUniformLocation("size");
			}
PointLight::~PointLight()
			{
			    delete Shader;
			}
void PointLight::Render(Camera* pGameCamera, int width, int height)
			{
				Assistant TM;
				TM.WorldPos(position[0],position[1],position[2]);
				TM.SetCamera(pGameCamera->GetPos(), pGameCamera->GetTarget(), pGameCamera->GetUp());
				TM.SetPerspectiveProj(30.0f, width, height, 1.0f, 1000.0f);


                shaderProgram->
				//glUseProgram(shaderProgramID);
				glBindBuffer(GL_ARRAY_BUFFER, VBO);
				glVertexAttribPointer(positionID,3,GL_FLOAT,GL_FALSE,0,0);


				glUniformMatrix4fv(gWorldID, 1, GL_TRUE, (const GLfloat*)TM.GetTSRVC());
				glUniform4f(PixelColorID,color[0],color[1],color[2],1);
				glUniform1f(PointSizeID, 5.0);
				glEnableVertexAttribArray(positionID);
				glDrawArrays(GL_POINTS,0,1);
				glDisableVertexAttribArray(positionID);
			}



Line::Line(Vector3f pos1, Vector3f pos2, Vector3f color)
			{
				char* vertexShaderSorceCode=ReadFile("Shaders/lightVS.vsh");
				char* fragmentShaderSourceCode=ReadFile("Shaders/lightFS.fsh");
				GLuint vertexShaderID=MakeVertexShader(vertexShaderSorceCode);
				GLuint fragmentShaderID=MakeFragmentShader(fragmentShaderSourceCode);
				shaderProgramID=MakeShaderProgram(vertexShaderID, fragmentShaderID);

				glGenBuffers(1, &VBO);
				glBindBuffer(GL_ARRAY_BUFFER, VBO);
				glBufferData(GL_ARRAY_BUFFER, 6*sizeof(float),NULL, GL_STATIC_DRAW);

				pos[0]=pos1.x;
				pos[1]=pos1.y;
				pos[2]=pos1.z;
				pos[3]=pos2.x;
				pos[4]=pos2.y;
				pos[5]=pos2.z;

				col[0]=color.x;
				col[1]=color.y;
				col[2]=color.z;
				glBufferSubData(GL_ARRAY_BUFFER,0,sizeof(pos),pos);
				positionID=	glGetAttribLocation(shaderProgramID,"position");
				gWorldID=	glGetUniformLocation(shaderProgramID, "gWVCP");
				PixelColorID= glGetUniformLocation(shaderProgramID, "PixelColor");
				PointSizeID= glGetUniformLocation(shaderProgramID, "size");
			}
Line::Line(Vector3f pos1, Vector3f pos2, Vector3f color,GLuint shader)
			{
				shaderProgramID=shader;
				glGenBuffers(1, &VBO);
				glBindBuffer(GL_ARRAY_BUFFER, VBO);
				glBufferData(GL_ARRAY_BUFFER, 6*sizeof(float),NULL, GL_STATIC_DRAW);

				pos[0]=pos1.x;
				pos[1]=pos1.y;
				pos[2]=pos1.z;
				pos[3]=pos2.x;
				pos[4]=pos2.y;
				pos[5]=pos2.z;

				col[0]=color.x;
				col[1]=color.y;
				col[2]=color.z;
				glBufferSubData(GL_ARRAY_BUFFER,0,sizeof(pos),pos);
				positionID=	glGetAttribLocation(shaderProgramID,"position");
				gWorldID=	glGetUniformLocation(shaderProgramID, "gWVCP");
				PixelColorID= glGetUniformLocation(shaderProgramID, "PixelColor");
				PointSizeID= glGetUniformLocation(shaderProgramID, "size");
			}
Line::~Line()
			{
			}
void Line::Render(Camera* pGameCamera, int width, int height)
			{
				Assistant TM;
				TM.WorldPos(0,0,0);
				TM.SetCamera(pGameCamera->GetPos(), pGameCamera->GetTarget(), pGameCamera->GetUp());
				TM.SetPerspectiveProj(30.0f, width, height, 1.0f, 1000.0f);



				glUseProgram(shaderProgramID);
				glBindBuffer(GL_ARRAY_BUFFER, VBO);
				glVertexAttribPointer(positionID,3,GL_FLOAT,GL_FALSE,0,0);


				glUniformMatrix4fv(gWorldID, 1, GL_TRUE, (const GLfloat*)TM.GetTSRVC());
				glUniform1f(PointSizeID,1.5);
				glUniform4f(PixelColorID, col[0],col[1],col[2],1.0);
				glEnableVertexAttribArray(positionID);
				glDrawArrays(GL_LINES,0,2);
				glDisableVertexAttribArray(positionID);
			}
